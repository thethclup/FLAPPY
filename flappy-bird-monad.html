<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird - Monad Testnet</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        .container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        canvas {
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        .ui {
            margin-top: 15px;
        }
        .button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        .button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        .wallet-info {
            background: rgba(0, 0, 0, 0.1);
            padding: 10px;
            border-radius: 10px;
            margin: 10px 0;
        }
        .score-display {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin: 10px 0;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üê¶ Flappy Bird - Monad Testnet</h1>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        
        <div class="ui">
            <div class="score-display">Score: <span id="currentScore">0</span> | High Score: <span id="highScore">0</span></div>
            
            <div class="wallet-info">
                <div>Wallet: <span id="walletAddress">Not Connected</span></div>
                <div>Network: <span id="networkName">Not Connected</span></div>
            </div>
            
            <button id="connectWallet" class="button">Connect Wallet</button>
            <button id="startGame" class="button" disabled>Start Game</button>
            <button id="submitScore" class="button" disabled>Submit Score to Blockchain</button>
            <button id="claimReward" class="button" disabled>Claim Reward</button>
            
            <div id="status" class="status" style="display: none;"></div>
            
            <div style="margin-top: 20px; font-size: 14px; color: #666;">
                <p>üéÆ Tap SPACE or click to flap</p>
                <p>üèÜ Score 10+ to unlock blockchain rewards</p>
                <p>üîó Connect to Monad Testnet to save high scores</p>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let gameOver = false;
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        
        // Web3 variables
        let web3 = null;
        let userAccount = null;
        let contract = null;
        
        // Monad testnet configuration
        const MONAD_CONFIG = {
            chainId: '0x29A', // 666 in hex (placeholder - use actual Monad chain ID)
            chainName: 'Monad Testnet',
            rpcUrls: ['https://testnet-rpc.monad.xyz'], // placeholder URL
            nativeCurrency: {
                name: 'MON',
                symbol: 'MON',
                decimals: 18
            },
            blockExplorerUrls: ['https://testnet-explorer.monad.xyz']
        };
        
        // Simple contract ABI for score storage
        const CONTRACT_ABI = [
            {
                "inputs": [{"internalType": "uint256", "name": "score", "type": "uint256"}],
                "name": "setScore",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "player", "type": "address"}],
                "name": "getScore",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        // Placeholder contract address (deploy actual contract)
        const CONTRACT_ADDRESS = '0x1234567890123456789012345678901234567890';
        
        // Game objects
        const bird = {
            x: 50,
            y: 200,
            width: 30,
            height: 30,
            velocity: 0,
            gravity: 0.5,
            jumpPower: -8
        };
        
        const pipes = [];
        const pipeWidth = 60;
        const pipeGap = 180;
        let pipeTimer = 0;
        
        // Initialize high score display
        document.getElementById('highScore').textContent = highScore;
        
        // Game functions
        function resetGame() {
            bird.y = 200;
            bird.velocity = 0;
            pipes.length = 0;
            score = 0;
            gameOver = false;
            pipeTimer = 0;
            document.getElementById('currentScore').textContent = score;
        }
        
        function updateBird() {
            if (!gameRunning || gameOver) return;
            
            bird.velocity += bird.gravity;
            bird.y += bird.velocity;
            
            // Check boundaries
            if (bird.y + bird.height > canvas.height || bird.y < 0) {
                endGame();
            }
        }
        
        function updatePipes() {
            if (!gameRunning || gameOver) return;
            
            // Add new pipes
            pipeTimer++;
            if (pipeTimer > 90) {
                const gapY = Math.random() * (canvas.height - pipeGap - 200) + 100;
                pipes.push({
                    x: canvas.width,
                    topHeight: gapY,
                    bottomY: gapY + pipeGap,
                    passed: false
                });
                pipeTimer = 0;
            }
            
            // Update pipe positions
            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= 2;
                
                // Check for scoring
                if (!pipe.passed && pipe.x + pipeWidth < bird.x) {
                    pipe.passed = true;
                    score++;
                    document.getElementById('currentScore').textContent = score;
                    
                    // Update high score
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('highScore', highScore);
                        document.getElementById('highScore').textContent = highScore;
                    }
                }
                
                // Check collisions
                if (pipe.x < bird.x + bird.width && pipe.x + pipeWidth > bird.x) {
                    if (bird.y < pipe.topHeight || bird.y + bird.height > pipe.bottomY) {
                        endGame();
                    }
                }
                
                // Remove off-screen pipes
                if (pipe.x + pipeWidth < 0) {
                    pipes.splice(i, 1);
                }
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw bird
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(bird.x, bird.y, bird.width, bird.height);
            
            // Draw bird details
            ctx.fillStyle = '#FF6347';
            ctx.fillRect(bird.x + 20, bird.y + 5, 8, 5); // beak
            ctx.fillStyle = '#000';
            ctx.fillRect(bird.x + 5, bird.y + 8, 3, 3); // eye
            
            // Draw pipes
            ctx.fillStyle = '#228B22';
            for (const pipe of pipes) {
                // Top pipe
                ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
                // Bottom pipe
                ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
                
                // Pipe caps
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(pipe.x - 5, pipe.topHeight - 20, pipeWidth + 10, 20);
                ctx.fillRect(pipe.x - 5, pipe.bottomY, pipeWidth + 10, 20);
                ctx.fillStyle = '#228B22';
            }
            
            // Draw ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
            
            // Draw game over message
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FFF';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 50);
                
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2);
                
                if (score >= 10) {
                    ctx.fillText('üèÜ Reward Available!', canvas.width / 2, canvas.height / 2 + 40);
                }
            }
        }
        
        function gameLoop() {
            updateBird();
            updatePipes();
            draw();
            
            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        function startGame() {
            resetGame();
            gameRunning = true;
            document.getElementById('startGame').disabled = true;
            document.getElementById('submitScore').disabled = true;
            document.getElementById('claimReward').disabled = true;
            gameLoop();
        }
        
        function endGame() {
            gameOver = true;
            gameRunning = false;
            document.getElementById('startGame').disabled = false;
            
            if (userAccount && score > 0) {
                document.getElementById('submitScore').disabled = false;
            }
            
            if (score >= 10) {
                document.getElementById('claimReward').disabled = false;
            }
        }
        
        function jump() {
            if (gameRunning && !gameOver) {
                bird.velocity = bird.jumpPower;
            }
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            }
        });
        
        canvas.addEventListener('click', jump);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            jump();
        });
        
        document.getElementById('startGame').addEventListener('click', startGame);
        
        // Web3 functions
        async function connectWallet() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    
                    const accounts = await web3.eth.getAccounts();
                    userAccount = accounts[0];
                    
                    // Check if on Monad testnet
                    const chainId = await web3.eth.getChainId();
                    if (chainId !== parseInt(MONAD_CONFIG.chainId, 16)) {
                        await switchToMonadTestnet();
                    }
                    
                    document.getElementById('walletAddress').textContent = 
                        userAccount.substring(0, 6) + '...' + userAccount.substring(38);
                    document.getElementById('networkName').textContent = 'Monad Testnet';
                    document.getElementById('connectWallet').textContent = 'Connected';
                    document.getElementById('connectWallet').disabled = true;
                    document.getElementById('startGame').disabled = false;
                    
                    // Initialize contract
                    contract = new web3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
                    
                    showStatus('Wallet connected successfully!', 'success');
                } else {
                    showStatus('Please install MetaMask or another Web3 wallet', 'error');
                }
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showStatus('Failed to connect wallet: ' + error.message, 'error');
            }
        }
        
        async function switchToMonadTestnet() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: MONAD_CONFIG.chainId }]
                });
            } catch (switchError) {
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [MONAD_CONFIG]
                        });
                    } catch (addError) {
                        throw new Error('Failed to add Monad testnet');
                    }
                } else {
                    throw switchError;
                }
            }
        }
        
        async function submitScore() {
            if (!contract || !userAccount) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }
            
            try {
                showStatus('Submitting score to blockchain...', 'info');
                
                const tx = await contract.methods.setScore(score).send({
                    from: userAccount,
                    gas: 100000
                });
                
                showStatus(`Score submitted! Transaction: ${tx.transactionHash}`, 'success');
                document.getElementById('submitScore').disabled = true;
            } catch (error) {
                console.error('Error submitting score:', error);
                showStatus('Failed to submit score: ' + error.message, 'error');
            }
        }
        
        async function claimReward() {
            if (!userAccount) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }
            
            try {
                showStatus('Claiming reward...', 'info');
                
                // Simulate reward claim (in real implementation, this would interact with a reward contract)
                const rewardAmount = Math.floor(score / 10) * 100; // 100 MON per 10 points
                
                // This is a simulation - in real implementation, you'd call a smart contract
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                showStatus(`Reward claimed! You received ${rewardAmount} testnet MON tokens!`, 'success');
                document.getElementById('claimReward').disabled = true;
            } catch (error) {
                console.error('Error claiming reward:', error);
                showStatus('Failed to claim reward: ' + error.message, 'error');
            }
        }
        
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }
        
        // Event listeners for blockchain functions
        document.getElementById('connectWallet').addEventListener('click', connectWallet);
        document.getElementById('submitScore').addEventListener('click', submitScore);
        document.getElementById('claimReward').addEventListener('click', claimReward);
        
        // Initialize game
        draw();
        
        // Handle wallet account changes
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    userAccount = null;
                    document.getElementById('walletAddress').textContent = 'Not Connected';
                    document.getElementById('networkName').textContent = 'Not Connected';
                    document.getElementById('connectWallet').textContent = 'Connect Wallet';
                    document.getElementById('connectWallet').disabled = false;
                    document.getElementById('startGame').disabled = true;
                }
            });
        }
    </script>
</body>
</html>